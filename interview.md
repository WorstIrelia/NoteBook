Q: 为什么STL allocator不加锁
A: STL allocator底层调用的malloc是线程安全的，多线程分配空间的时候不会出现问题。另外，SGI STL的allocator分配空间有两种分配方式，内存池的那种其采用的数据结构不是线程安全的，但其实现的时候保证了线程安全的，

知识点 线程安全 < 可重入
线程安全大部分只多个线程调用同一个函数，在上下文切换的过程中函数运行的结果没有改变。
可重入函数指一个函数被信号中断后，若在信号中断中再次调用，结果还是不会改变。
引用了全局变量，静态变量，指针，特别小心。


**注** 对STL的所有容器进行写入操作的时候都需要自己加锁，读是线程安全的，写不是。


可重入函数一定是线程安全的。
线程安全不一定是可重入的。


Q: DDOS
A: SYN floot 利用了协议设计上的一个缺陷，半连接队列，常见解决方法，缩短SYN timeout时间，采用SYN cookie判断，但都不是很有效的办法。


Q: 查看进程打开的描述符 
A: lsof


Q: c++ 空类的函数
A: 构造，析构，拷贝构造，赋值，取地址，const取地址。

Q: 守护进程
A: 在后台运行且不受任何终端控制的进程
创建方法: fork()一次，杀死父进程，第一次fork是为了使得子进程不在是进程组组长，可以设置新的会话id。
        setsid()，设置新的会话id,避免外部终端的连接。
        再fokr()一次，成为子进程，不是该会话的组长，彻底避免终端的连接。(某些情况会打开终端，并没有详细说明)
        关闭所有文件描述符，打开/dev/null。防止出错。
        设置文件umask() 这东西也继承了父进程。
        改变工作根目录。


Q: GDB调试
A: 编译的时候 -g  gdb调试可以list出代码
    基本指令
    b 20 //20行下断点
    c //continue 下一个断点
    disas //汇编
    s //step 下一句汇编语句
    n //next 下一句
    info all // info --help