Q: 为什么STL allocator不加锁
A: STL allocator底层调用的malloc是线程安全的，多线程分配空间的时候不会出现问题。另外，SGI STL的allocator分配空间有两种分配方式，内存池的那种其采用的数据结构不是线程安全的，但其实现的时候保证了线程安全的，

知识点 线程安全 < 可重入
线程安全大部分只多个线程调用同一个函数，在上下文切换的过程中函数运行的结果没有改变。
可重入函数指一个函数被信号中断后，若在信号中断中再次调用，结果还是不会改变。
引用了全局变量，静态变量，指针，特别小心。


**注** 对STL的所有容器进行写入操作的时候都需要自己加锁，读是线程安全的，写不是。


可重入函数一定是线程安全的。
线程安全不一定是可重入的。


Q: DDOS
A: SYN floot 利用了协议设计上的一个缺陷，半连接队列，常见解决方法，缩短SYN timeout时间，采用SYN cookie判断，但都不是很有效的办法。
昨天脑洞了一个方法，可以在协议栈里对某个ip的连接数设置一个阈值，超过这个阈值本地直接丢弃掉。这个方法可以解决一台机器不断进行包的发送的情况。



Q: 查看进程打开的描述符 
A: lsof


Q: c++ 空类的函数
A: 构造，析构，拷贝构造，赋值，取地址，const取地址。

Q: 守护进程
A: 在后台运行且不受任何终端控制的进程
创建方法: fork()一次，杀死父进程，第一次fork是为了使得子进程不在是进程组组长，可以设置新的会话id。
        setsid()，设置新的会话id,避免外部终端的连接。
        再fokr()一次，成为子进程，不是该会话的组长，彻底避免终端的连接。(某些情况会打开终端，并没有详细说明)
        关闭所有文件描述符，打开/dev/null。防止出错。
        设置文件umask() 这东西也继承了父进程。
        改变工作根目录。


Q: GDB调试
A: 编译的时候 -g  gdb调试可以list出代码
    基本指令
    b 20 //20行下断点
    c //continue 下一个断点
    disas //汇编
    s //step 下一句汇编语句
    n //next 下一句
    info all // info --help



Q:  TCP连接断开的几种情况    
A:  **当应用程序接受不到网络协议栈中缓冲区的数据的时候，就会发送RST。**
    **发送接受RST的双方都要关闭网络协议栈中的缓冲区。**
    server端的进程crash掉。
    此时内核关闭所有的fd,server端会给client端发送第一个FIN,进入FIN_WAIT1
    client端返回ACK。此时如果写socket，server端会返回RST报文，如果读socket，会返回0,但是不会引起RST报文。

    server端电脑崩溃，网络断开等，区别上述情况是没有发FIN报文。
    client端读socket，将会一直阻塞，直到超时,如果有超时机制，将会重传。
    如果写socket,内核网络协议栈将会不断超时重传，直到次数超过一定的限制(berkeley 重传12此，约等待九分钟，返回错误)。

    server端电脑崩溃，网络断开，重启。
    client写数据，RST。
    client读数据，可能会一直阻塞。


Q:  static 实现原理
A:  对于函数来讲，static 修饰的变量名经过编译汇编之后，生成的可重定位文件里，其符号类型是local，不是global，链接过程中不会重定位该符号。

Q:  编译一个点c文件的全过程
A:  第一阶段，先进行预处理，替换算有宏，文件包含，条件编译等，形成一个字符流文件。
    接下来进行词法分析，语法分析，语义分析，形成汇编代码。
    然后汇编器进行汇编，形成可重定向文件。
    连接器在进行链接，形成可执行文件，linux是elf文件。

Q:  静态链接和动态链接。
A:  




Q:  构造函数里调用虚函数
A:  实际上并没有调用虚函数。GDB发现，虚函数表是放在.rodata中的，只用初始化一个虚函数指针就行了。直接调用的是函数，先基类，在派生类。

Q:  EPOLLIN EPOLLOUT
A:  EPOLLIN 检测到socket可读
    EPOLLOUT 当一个内核缓冲区被写满的时候，socket不可写，可以用EPOLLOUT来监测socket是否可写。

Q:  函数调用栈的变化。
A:  变量先压栈，在压返回值，实际上变量会压寄存器，返回值在%rax.

Q:  纯虚函数可以有函数体吗
A:  可以有，但是该类还是不能实例化。可以把虚析构函数定义为纯虚函数，给派生类提供默认或者备用的方法。

Q:  GDB的实现原理
A:  linux下有一个系统调用叫做ptrace, 可以观察其他进程的运行以及核心印象以及寄存器，其他进程的信号都会优先被父进程捕获。
    (链接))[https://blog.csdn.net/u012658346/article/details/51159971]