# 01背包

1. 如果不要求装满，直接从后往前更新

状态转移方程 dp[i]=max(dp[i-weight]+value,dp[i]) //求最大值
           dp[i]=min(dp[i-weight]+value,dp[i]) //求最小值 初始化为正无穷 INF dp[0]=0

2. 如果要求装满，必须在dp[i-weight]是一个可行的状态的时候更新

## 完全背包

1. 如果不要求装满，直接从前往后更新

状态转移方程 dp[i]=max(dp[i-weight]+value,dp[i]) //最大值
           dp[i]=min(dp[i-weight]+value,dp[i]) //最小值，初始化为正无穷 INF dp[0]=0

2. 如果要求装满，必须在dp[i-weight]是一个可行的状态的时候更新

## 有限制的背包

1. 简单写法,二进制分解，转化成01背包

有 x 个物品 (如10个背包) (1010，二进制，分解为1,2,4,3） 这样任意一个<=x的数都能被线性的表出

带一个log(x) 比较好写，大概乘上一个10的常数。

补单调队列优化。

## 混合背包 正向 逆向更新即可 有多重log n 分解

## 输出方案 必须记录二维数组来进行

## 字典序最小

倒序输入，转移输出即可。

## 方案总数

dp[i][j]=dp[i-1][j]+dp[i-1][j-weight]

## 第K优解

加一维状态